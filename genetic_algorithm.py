# -*- coding: utf-8 -*-
"""Genetic Algorithm

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SLJH0GkoTuqX_puwSQzuNZseJutMrOdQ
"""

import random
import numpy as np
from collections import defaultdict

# Problem Constants:
# Activities with their expected enrollment
ACTIVITIES = {
    'SLA100A': {'enrollment': 50},
    'SLA100B': {'enrollment': 50},
    'SLA191A': {'enrollment': 50},
    'SLA191B': {'enrollment': 50},
    'SLA201': {'enrollment': 50},
    'SLA291': {'enrollment': 50},
    'SLA303': {'enrollment': 60},
    'SLA304': {'enrollment': 25},
    'SLA394': {'enrollment': 20},
    'SLA449': {'enrollment': 60},
    'SLA451': {'enrollment': 100}
}

# Rooms with their capacities
ROOMS = {
    'Slater 003': 45,
    'Roman 216': 30,
    'Loft 206': 75,
    'Roman 201': 50,
    'Loft 310': 108,
    'Beach 201': 60,
    'Beach 301': 75,
    'Logos 325': 450,
    'Frank 119': 60
}

# Available time slots
TIMES = ['10 AM', '11 AM', '12 PM', '1 PM', '2 PM', '3 PM']

# All available facilitators
'''
- Works best overseeing small group activities
- Some are preferred for activities and some can "cross over"
- Any facilitator can over see any activity
- need to avoid stopgap
'''
FACILITATORS = ['Lock', 'Glen', 'Banks', 'Richards', 'Shaw',
               'Singer', 'Uther', 'Tyler', 'Numen', 'Zeldin']

# Preferred and other facilitators for each activity
for activity in ACTIVITIES:
    ACTIVITIES[activity]['preferred'] = []
    ACTIVITIES[activity]['other'] = []

# Set up facilitator preferences
ACTIVITIES['SLA100A']['preferred'] = ['Glen', 'Lock', 'Banks', 'Zeldin']
ACTIVITIES['SLA100A']['other'] = ['Numen', 'Richards']

ACTIVITIES['SLA100B']['preferred'] = ['Glen', 'Lock', 'Banks', 'Zeldin']
ACTIVITIES['SLA100B']['other'] = ['Numen', 'Richards']

ACTIVITIES['SLA191A']['preferred'] = ['Glen', 'Lock', 'Banks', 'Zeldin']
ACTIVITIES['SLA191A']['other'] = ['Numen', 'Richards']

ACTIVITIES['SLA191B']['preferred'] = ['Glen', 'Lock', 'Banks', 'Zeldin']
ACTIVITIES['SLA191B']['other'] = ['Numen', 'Richards']

ACTIVITIES['SLA201']['preferred'] = ['Glen', 'Banks', 'Zeldin', 'Shaw']
ACTIVITIES['SLA201']['other'] = ['Numen', 'Richards', 'Singer']

ACTIVITIES['SLA291']['preferred'] = ['Lock', 'Banks', 'Zeldin', 'Singer']
ACTIVITIES['SLA291']['other'] = ['Numen', 'Richards', 'Shaw', 'Tyler']

ACTIVITIES['SLA303']['preferred'] = ['Glen', 'Zeldin', 'Banks']
ACTIVITIES['SLA303']['other'] = ['Numen', 'Singer', 'Shaw']

ACTIVITIES['SLA304']['preferred'] = ['Glen', 'Banks', 'Tyler']
ACTIVITIES['SLA304']['other'] = ['Numen', 'Singer', 'Shaw', 'Richards', 'Uther', 'Zeldin']

ACTIVITIES['SLA394']['preferred'] = ['Tyler','Singer']
ACTIVITIES['SLA394']['other'] = ['Richards', 'Zeldin']

ACTIVITIES['SLA449']['preferred'] = ['Tyler', 'Singer', 'Shaw']
ACTIVITIES['SLA449']['other'] = ['Zeldin, Uther']

ACTIVITIES['SLA451']['preferred'] = ['Tyler', 'Singer', 'Shaw']
ACTIVITIES['SLA451']['other'] = ['Zeldin', 'Uther', 'Richards', 'Banks']


# Represents one potential schedule solution
class ScheduleChromosome:

    def __init__(self): #Initialize a chromosome with empty genes
        self.genes = {}  # Each gene represents an activity's assignment
        self.fitness = 0  # Fitness score of this chromosome

    # Creates random valid schedule
    def initialize_random(self):

        for activity in ACTIVITIES:
            # Assign random room, time, and facilitator
            self.genes[activity] = {
                'room': random.choice(list(ROOMS.keys())),
                'time': random.choice(TIMES),
                'facilitator': random.choice(FACILITATORS)
            }
    #Calculate the fitness score for this chromosome
    def calculate_fitness(self):
        """
        Implements all scoring rules:
        1. Room conflicts (-0.5)

        2. Room size penalties/rewards:
          - too small: -0.5
          - too big, 3*Cap < Cap < 6*Cap: -0.2
          - too big, Cap > 6: -0.4,
          - Else: +0.3

        3. Facilitator preferences:
          -  Perfered: +0.5
          - Listed others: 0.2
          - Else: -0.1

        4. Facilitator load constraints:
          - Acctivity facilitator, Activity = 1: +0.2
          - Acctivity facilitator, Activity conflict: -0.2
          - facilitator, 1-2 activities: -.04
            - Not Dr. Tyler if < 2 activities
          - Acctivities > 4: -0.5

         5. Special rules for SLA100/SLA191 sections and consecutive time slots:
          - SLA 100 sections time diff > 4 hours: + 0.5
          - Both SLA 100 same time slot: -0.5
          - SLA 191 sections time diff > 4 hours: + 0.5
          - Both SLA 191 same time slot: -0.5
          - SLA 191 and SLA 100  in consecutive time slots: +0.5
            - if 1 activitity in Roman or Beach, and othet not: -0.4
          - SLA 191 and SLA 100 time diff >= 1: +0.25
          - SLA 191 and SLA 100 same time slot: -0.25
        """
        total_fitness = 0 # Start fitness points
        facilitator_load = defaultdict(int)  # Total activities per facilitator
        time_slots = defaultdict(lambda: defaultdict(list))  # time -> room -> [activities]
        facilitator_schedule = defaultdict(lambda: defaultdict(list))  # facilitator -> time -> [activities]

        #Collect data about the schedule
        for activity, assignment in self.genes.items():
            room = assignment['room']
            time = assignment['time']
            facilitator = assignment['facilitator']
            enrollment = ACTIVITIES[activity]['enrollment']
            room_capacity = ROOMS[room]

            # Track which activities are in each room at each time
            time_slots[time][room].append(activity)

            facilitator_schedule[facilitator][time].append(activity)
            facilitator_load[facilitator] += 1


        #Calculate fitness for each activity
        for activity, assignment in self.genes.items():
            room = assignment['room']
            time = assignment['time']
            facilitator = assignment['facilitator']
            enrollment = ACTIVITIES[activity]['enrollment']
            room_capacity = ROOMS[room]

            activity_fitness = 0

            # 1. Check for room conflicts (same room/time)
            if len(time_slots[time][room]) > 1:
                activity_fitness -= 0.5

            # 2. Room size constraints
            if room_capacity < enrollment:
                activity_fitness -= 0.5
            elif room_capacity > 3 * enrollment:
                if room_capacity > 6 * enrollment:
                    activity_fitness -= 0.4
                else:
                    activity_fitness -= 0.2
            else:
                activity_fitness += 0.3

            # 3. Facilitator preferences
            if facilitator in ACTIVITIES[activity]['preferred']:
                activity_fitness += 0.5
            elif facilitator in ACTIVITIES[activity]['other']:
                activity_fitness += 0.2
            else: #Not in either list
                activity_fitness -= 0.1

            # 4. Facilitator load constraints
            if len(facilitator_schedule[facilitator][time]) == 1:
                activity_fitness += 0.2
            # Check for same-time activities
            elif len(facilitator_schedule[facilitator][time]) > 1:
                activity_fitness -= 0.2

            # Check total facilitator load
            if facilitator_load[facilitator] > 4:
                activity_fitness -= 0.5
            elif facilitator_load[facilitator] <= 2 and facilitator != 'Tyler':
                activity_fitness -= 0.4

            #facilitator scheduled for consecutive time slots
            for other_activity, other_assignment in self.genes.items():
              if other_activity == activity:
                continue  # Don't compare with self

              #Only check activities with the same facilitator
              if assignment['facilitator'] == other_assignment['facilitator']:
                time_diff = abs(TIMES.index(assignment['time']) - TIMES.index(other_assignment['time']))

                # Consecutive time slots (1 hour apart)
                if time_diff == 1:
                    activity_fitness += 0.5

            # 5. Activity-specific rules
            # Handle SLA100 and SLA191 sections
            if activity.startswith('SLA100'):
                other_section = 'SLA100B' if activity == 'SLA100A' else 'SLA100A'
                other_time = self.genes[other_section]['time']
                if time == other_time: #room time conflict
                    activity_fitness -= 0.5
                elif abs(TIMES.index(time) - TIMES.index(other_time)) > 2:  # More than 4 hours apart
                    activity_fitness += 0.5

            if activity.startswith('SLA191'):
                other_section = 'SLA191B' if activity == 'SLA191A' else 'SLA191A'
                other_time = self.genes[other_section]['time']
                if time == other_time: #room time conflict
                    activity_fitness -= 0.5
                elif abs(TIMES.index(time) - TIMES.index(other_time)) > 2: #More than 4 hours apart
                    activity_fitness += 0.5

                # Check SLA101 consecutive time slots
                for sla101 in ['SLA100A', 'SLA100B']:
                    sla101_time = self.genes[sla101]['time']
                    time_diff = abs(TIMES.index(time) - TIMES.index(sla101_time)) #check consecutiveness
                    if time_diff == 1:  # Consecutive
                        activity_fitness += 0.5
                        # Check building separation
                        sla101_room = self.genes[sla101]['room']
                        if ('Roman' in room or 'Beach' in room) != ('Roman' in sla101_room or 'Beach' in sla101_room):
                            activity_fitness -= 0.4
                    elif time_diff == 2:  # 1 hour apart
                        activity_fitness += 0.25
                    elif time_diff == 0:  # Same time
                        activity_fitness -= 0.25

            total_fitness += activity_fitness

        self.fitness = total_fitness
        return total_fitness

# Genetic Algorithm Class
class GeneticAlgorithm: #Implements the genetic algorithm for schedule optimization

    #Initialize GA with parameters
    def __init__(self, population_size=500, mutation_rate=0.01):
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.population = []  # Current population of chromosomes
        self.generation = 0  # Current generation count
        self.fitness_history = []  # Tracks best fitness per generation

    #Create the initial random population
    def initialize_population(self):
        self.population = []
        for _ in range(self.population_size):
            chromosome = ScheduleChromosome()
            chromosome.initialize_random()
            chromosome.calculate_fitness()
            self.population.append(chromosome)

    #Select two parents using fitness-proportional selection
    def select_parents(self):
        # Get all fitness values
        fitness_values = [c.fitness for c in self.population]

        # Softmax normalization to convert fitness to probabilities
        # Shift values for numerical stability
        max_fitness = max(fitness_values)
        adjusted_fitness = [f - max_fitness for f in fitness_values]
        exp_values = np.exp(adjusted_fitness)
        probabilities = exp_values / np.sum(exp_values)

        # Select two distinct parents
        parent1, parent2 = random.choices(self.population, weights=probabilities, k=2)
        while parent1 == parent2:  # Ensure we get two different parents
            parent2 = random.choices(self.population, weights=probabilities, k=1)[0]

        return parent1, parent2

    #Create offspring through uniform crossover
    def crossover(self, parent1, parent2):
        child = ScheduleChromosome()

        # For each activity, randomly select assignment from either parent
        for activity in ACTIVITIES:
            if random.random() < 0.5:  # 50% chance to take from either parent
                child.genes[activity] = parent1.genes[activity].copy()
            else:
                child.genes[activity] = parent2.genes[activity].copy()

        return child

    #Apply random mutations to the chromosome
    def mutate(self, chromosome):
        for activity in chromosome.genes:
            # Mutate room with probability mutation_rate
            if random.random() < self.mutation_rate:
                chromosome.genes[activity]['room'] = random.choice(list(ROOMS.keys()))

            # Mutate time with probability mutation_rate
            if random.random() < self.mutation_rate:
                chromosome.genes[activity]['time'] = random.choice(TIMES)

            # Mutate facilitator with probability mutation_rate
            if random.random() < self.mutation_rate:
                chromosome.genes[activity]['facilitator'] = random.choice(FACILITATORS)

        return chromosome
    #Run one generation of evolution
    def evolve_generation(self):
        new_population = []

        # Elitism: Keep the best chromosome from previous generation
        best_chromosome = max(self.population, key=lambda x: x.fitness)
        new_population.append(best_chromosome)

        # Generate offspring until population is full
        while len(new_population) < self.population_size:
            # Selection
            parent1, parent2 = self.select_parents()

            # Crossover
            child = self.crossover(parent1, parent2)

            # Mutation
            child = self.mutate(child)

            # Evaluation
            child.calculate_fitness()
            new_population.append(child)

        # Replace old population with new generation
        self.population = new_population
        self.generation += 1

        # Track best fitness
        current_best = max(c.fitness for c in self.population)
        self.fitness_history.append(current_best)

        return current_best

    #Check if termination conditions are met
    def should_terminate(self):
        if self.generation < 100:
            return False

        # Check if improvement is less than 1% over last 100 generations
        if len(self.fitness_history) >= 100:
            prev_fitness = self.fitness_history[-100]
            current_fitness = self.fitness_history[-1]
            improvement = (current_fitness - prev_fitness) / abs(prev_fitness)
            return improvement < 0.01

        return False

    #Run the genetic algorithm until termination
    def run(self):
        self.initialize_population()

        print("Starting genetic algorithm...")
        print(f"Initial best fitness: {max(c.fitness for c in self.population):.2f}")

        while not self.should_terminate():
            best_fitness = self.evolve_generation()
            if self.generation % 10 == 0:  # Print progress every 10 generations
                print(f"Generation {self.generation}: Best fitness = {best_fitness:.2f}")

        print(f"\nCompleted after {self.generation} generations")
        best_schedule = max(self.population, key=lambda x: x.fitness)
        print(f"Final best fitness: {best_schedule.fitness:.2f}")

        return best_schedule

#Print the schedule in a readable format
def print_schedule(schedule): #Chat GPT Format output
    print("\nBest Schedule Found:")
    print(f"Fitness Score: {schedule.fitness:.2f}\n")

    print("{:<10} {:<10} {:<15} {:<10}".format("Activity", "Time", "Room", "Facilitator"))
    print("-" * 45)

    for activity in sorted(schedule.genes.keys()):
        assignment = schedule.genes[activity]
        print("{:<10} {:<10} {:<15} {:<10}".format(
            activity,
            assignment['time'],
            assignment['room'],
            assignment['facilitator']
        ))

#Save the schedule to a file
def save_schedule(schedule, filename):
    with open(filename, 'w') as f:
        f.write(f"Best Schedule (Fitness: {schedule.fitness:.2f})\n\n")
        f.write("{:<10} {:<10} {:<15} {:<10}\n".format("Activity", "Time", "Room", "Facilitator")) #ChatGPT format
        f.write("-" * 45 + "\n")
        for activity in sorted(schedule.genes.keys()):
            assignment = schedule.genes[activity]
            f.write("{:<10} {:<10} {:<15} {:<10}\n".format(
                activity,
                assignment['time'],
                assignment['room'],
                assignment['facilitator']
            ))

# ======================
# Main Execution
# ======================

if __name__ == "__main__":
    # Initialize and run the genetic algorithm
    ga = GeneticAlgorithm(population_size=500, mutation_rate=0.01)
    best_schedule = ga.run()

    # Display and save results
    print_schedule(best_schedule)
    save_schedule(best_schedule, "best_schedule.txt")